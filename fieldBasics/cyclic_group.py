# ============================================================================
# CYCLIC GROUP UTILITIES FOR CRYPTOGRAPHY
# ============================================================================
# Cyclic groups are fundamental in cryptography! They're used in:
# - Diffie-Hellman key exchange (works in cyclic groups)
# - ElGamal encryption (needs cyclic groups)
# - Digital signatures (DSA uses cyclic subgroups)
# - Elliptic curve cryptography (elliptic curves form cyclic groups)
# ============================================================================

# Simple imports - no need for complex importlib stuff
import prime
import generator


def get_cyclic_group_elements(g, P, order=None):
    """
    Get all elements of a cyclic group generated by g modulo P.
    
    What is a cyclic group?
    - A group where every element can be written as g^k for some k
    - The group is "generated" by g (we call g a generator)
    - Example: If g=3 and P=7, the group is {3^0, 3^1, 3^2, 3^3, 3^4, 3^5} mod 7
      which equals {1, 3, 2, 6, 4, 5} = {1, 2, 3, 4, 5, 6} (all non-zero mod 7)
    
    Why is this useful?
    - In crypto, we often need to list all elements in a subgroup
    - Helps us understand the structure of the group
    - Useful for testing and verification
    
    Args:
        g: The generator of the group
        P: The prime modulus
        order: The size of the group (how many elements)
              If None, uses P-1 (the full multiplicative group)
    
    Returns:
        List of all elements: [g^0, g^1, g^2, ..., g^(order-1)] mod P
    """
    elements = []
    
    # If order not specified, use P-1 (full multiplicative group)
    if order is None:
        order = P - 1
    
    # Generate all elements: g^0, g^1, g^2, ..., g^(order-1)
    for i in range(order):
        # Compute g^i mod P using fast exponentiation
        element = generator.modular_power(g, i, P)
        elements.append(element)
    
    return elements


def get_cyclic_groups(P):
    """
    Analyze all cyclic subgroups of the multiplicative group modulo prime P.
    
    This is a really important function for understanding finite fields!
    
    What are we doing here?
    - For a prime P, the multiplicative group has size P-1
    - If P-1 = q1^k1 * q2^k2 * ... (prime factorization)
    - Then for each prime factor qi, there's a cyclic subgroup of order qi^ki
    - These subgroups are generated by g^((P-1)/qi) where g is a primitive root
    
    Why is this useful in crypto?
    - Diffie-Hellman often uses subgroups (not the full group)
    - DSA uses specific subgroups
    - Understanding subgroups helps us choose secure parameters
    
    Example: P = 7
    - P-1 = 6 = 2^1 * 3^1
    - So we have subgroups of order 2 and order 3
    - If g=3 is a primitive root:
      * Subgroup of order 2: generated by 3^(6/2) = 3^3 = 6 mod 7
      * Subgroup of order 3: generated by 3^(6/3) = 3^2 = 2 mod 7
    
    Args:
        P: A prime number to analyze
    
    Returns:
        Dictionary with lots of useful information:
        - 'is_prime': Is P actually prime?
        - 'prime': The prime number P
        - 'p_minus_one': Value of P-1
        - 'factorization': Full factorization of P-1: {q1: k1, q2: k2, ...}
        - 'factorization_str': Nice string like "2^1 * 3^1"
        - 'prime_factors': Just the primes: [2, 3]
        - 'primitive_root': A primitive root we're using
        - 'all_primitive_roots': All primitive roots modulo P
        - 'num_primitive_roots': How many are there?
        - 'cyclic_subgroups': Dictionary of subgroups for each prime factor
    """
    # First, check if P is actually prime
    if not prime.is_prime(P):
        return {
            'is_prime': False,
            'error': f'{P} is not a prime number'
        }
    
    # Calculate P-1
    # This is the size of the multiplicative group
    p_minus_one = P - 1
    
    # Factorize P-1 to understand its structure
    # Example: if P-1 = 12, then factorization = {2: 2, 3: 1}
    # This means 12 = 2^2 * 3^1
    factorization = generator.factorize(p_minus_one)
    
    # Get a nice string representation
    factorization_str = generator.format_factorization(p_minus_one)
    
    # Get just the prime factors (without powers)
    # Example: if P-1 = 12, prime_factors = [2, 3]
    prime_factors = generator.get_prime_factors(p_minus_one)
    
    # Find all primitive roots (generators of the full group)
    # These are the numbers that generate the entire multiplicative group
    primitive_roots = generator.find_generators(P)
    
    # Check if we found any primitive roots
    if len(primitive_roots) == 0:
        return {
            'is_prime': True,
            'prime': P,
            'error': 'No primitive roots found'
        }
    
    # Use the first primitive root for our calculations
    # (We could use any of them, they all work the same)
    g = primitive_roots[0]
    
    # Now compute the cyclic subgroups
    # For each prime factor q of P-1, we create a subgroup
    cyclic_subgroups = {}
    
    for q in prime_factors:
        # Calculate (P-1) / q
        # This is the exponent we'll use to generate the subgroup
        divisor = p_minus_one // q
        
        # The generator of this subgroup is g^((P-1)/q)
        # This creates a subgroup of order q^k (where k is the power of q in factorization)
        subgroup_generator = generator.modular_power(g, divisor, P)
        
        # The order of the subgroup is q^k
        # Example: if q=2 and factorization[2]=3, then order = 2^3 = 8
        order = q ** factorization[q]
        
        # Get all elements in this subgroup
        elements = get_cyclic_group_elements(subgroup_generator, P, order)
        
        # Store information about this subgroup
        cyclic_subgroups[q] = {
            'prime_factor': q,              # The prime factor (e.g., 2)
            'power': factorization[q],       # The power (e.g., 3, so q^3)
            'generator': subgroup_generator, # The generator of this subgroup
            'order': order,                  # Size of the subgroup (q^power)
            'elements': elements             # All elements in the subgroup
        }
    
    # Return all the information we computed
    return {
        'is_prime': True,
        'prime': P,
        'p_minus_one': p_minus_one,
        'factorization': factorization,
        'factorization_str': factorization_str,
        'prime_factors': prime_factors,
        'primitive_root': g,
        'all_primitive_roots': primitive_roots,
        'num_primitive_roots': len(primitive_roots),
        'cyclic_subgroups': cyclic_subgroups
    }


if __name__ == "__main__":
    # Test the functions
    test_primes = [23]
    
    print("=== Cyclic Groups of Prime Numbers ===\n")
    
    for P in test_primes:
        result = get_cyclic_groups(P)
        
        # Check if there was an error
        if not result['is_prime']:
            print(f"P = {P}: {result['error']}\n")
            continue
        
        # Print basic information
        print(f"Prime: P = {result['prime']}")
        print(f"  P-1 = {result['p_minus_one']}")
        print(f"  Factorization: {result['p_minus_one']} = {result['factorization_str']}")
        print(f"  All primitive roots (generators): {result['all_primitive_roots']}")
        print(f"  Number of primitive roots: {result['num_primitive_roots']}")
        print(f"  Primitive root used for subgroups: g = {result['primitive_root']}")
        print()
        
        # Print information about each cyclic subgroup
        print("  Cyclic Subgroups:")
        for q in result['prime_factors']:
            subgroup = result['cyclic_subgroups'][q]
            print(f"    For prime factor q = {q} (power = {subgroup['power']}):")
            print(f"      Generator: g^((P-1)/{q}) = {result['primitive_root']}^({result['p_minus_one']}/{q}) = {subgroup['generator']}")
            print(f"      Order: {subgroup['order']}")
            print(f"      Elements: {subgroup['elements']}")
            print()
